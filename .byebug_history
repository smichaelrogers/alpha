exit
evaluate
roots.sort!.map { |r| r.score }
exit
c
DIR[@mx]
in_check?
roots.sort!.map { |r| r.score }
roots
@roots
evaluate
@root.score
@mx
@kings
exit
@moves[@ply - 1].inject { |s, m| s + MOBILITY[m.piece] + ATTACK[m.target] }
score
@moves[@ply - 1].first
@moves[@ply - 1].inject(0) { |s, m| s + MOBILITY[m.piece] + ATTACK[m.target] }
@moves[@ply - 2].inject(0) { |s, m| s + MOBILITY[m.piece] + ATTACK[m.target] }
@mx
@ply
puts Alpha.pp_board(@squares, @colors)
score
exit
s
exit
@mx
puts Alpha.pp_board(@squares, @colors)
Alpha.pp_board(@squares, @colors)
score
exit
p s
puts s
s
exit
SQ64[95 * -1]exit
all_pieces { |piece, color, from| (MATERIAL[piece]) + POSITION[piece][SQ64[from]] }
all_pieces { |piece, color, from| (MATERIAL[piece])}
all_pieces { |piece, color, from| (MATERIAL[piece]}
all_pieces { |piece, color, from| ((MATERIAL[piece] + POSITION[piece][SQ64[from * FLIP[color]]]) * FLIP[color]) }.inject(:+)
SQ64[98 * -1]
SQ64[95 * -1]
all_pieces { |piece, color, from| ((MATERIAL[piece] + POSITION[piece][SQ64[from * FLIP[color]]]) * FLIP[color]) }
FLIP[@mx]
@mx
@moves[@ply - 1].inject(0) { |s, m| s + MOBILITY[m.piece] + ATTACK[m.target] }
@moves
      })
        s + MOBILITY[m.piece] + ATTACK[m.target]
(@moves[@ply - 1].inject(0) { |s, m| 
score
exit
@moves[2]
@ply
@mx
@moves
@moves[n]
puts f
f
exit
@moves[@ply]
exit
@moves[@ply] = each_move
@moves[@ply]
@moves[@ply].to_enum
next
to_enum
g = each_move.each.to_a
g = each_move.each
g = each_move.to_enum
each_move do 
each_move
g.next
g.take
g = each_move { |m| m }
g = each_move
each_move
@moves[@ply].methods
@moves[@ply]
